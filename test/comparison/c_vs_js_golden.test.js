// test/comparison/c_vs_js_golden.test.js -- Broad C-vs-JS typGrid comparison
//
// Compares JS-generated terrain grids against C golden reference sessions
// across many seeds and depths. Reports per-seed/depth pass/fail with summary.
//
// Usage:
//   node --test test/comparison/c_vs_js_golden.test.js
//
// C golden sessions are generated by:
//   python3 test/comparison/c-harness/gen_map_sessions.py --c-golden
//
// These are *_c_golden.session.json files in test/comparison/maps/.

import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { readdirSync, readFileSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

import {
    generateMapsSequential, extractTypGrid, compareGrids, formatDiffs,
    typName, TYP_NAMES,
} from './session_helpers.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const MAPS_DIR = join(__dirname, 'maps');

// Discover all C golden session files
const goldenFiles = existsSync(MAPS_DIR)
    ? readdirSync(MAPS_DIR)
        .filter(f => f.endsWith('_c_golden.session.json'))
        .sort((a, b) => {
            // Sort numerically by seed
            const seedA = parseInt(a.match(/seed(\d+)/)?.[1] || '0');
            const seedB = parseInt(b.match(/seed(\d+)/)?.[1] || '0');
            return seedA - seedB;
        })
    : [];

if (goldenFiles.length === 0) {
    describe('C-vs-JS golden comparison', () => {
        it('no golden sessions found', () => {
            console.log('No *_c_golden.session.json files found in test/comparison/maps/');
            console.log('Generate them with: python3 test/comparison/c-harness/gen_map_sessions.py --c-golden');
        });
    });
} else {
    // Track summary statistics across all seeds/depths
    const summary = {
        total: 0,
        pass: 0,
        fail: 0,
        failuresByDepth: {},   // depth → count
        failuresBySeed: {},    // seed → [depths]
        terrainDiffTypes: {},  // "JS_TYPE→C_TYPE" → count
    };

    describe(`C-vs-JS golden comparison (${goldenFiles.length} seeds)`, () => {
        for (const file of goldenFiles) {
            const session = JSON.parse(readFileSync(join(MAPS_DIR, file), 'utf-8'));
            const seed = session.seed;
            const maxDepth = Math.max(...session.levels.map(l => l.depth));

            describe(`seed ${seed} (depths 1-${maxDepth})`, () => {
                let result;

                it('generates levels sequentially', () => {
                    result = generateMapsSequential(seed, maxDepth);
                });

                for (const level of session.levels) {
                    const depth = level.depth;

                    it(`depth ${depth} typGrid`, () => {
                        assert.ok(result, 'Level generation failed');
                        const jsGrid = result.grids[depth];
                        assert.ok(jsGrid, `JS did not generate depth ${depth}`);

                        const diffs = compareGrids(jsGrid, level.typGrid);
                        summary.total++;

                        if (diffs.length === 0) {
                            summary.pass++;
                        } else {
                            summary.fail++;
                            summary.failuresByDepth[depth] = (summary.failuresByDepth[depth] || 0) + 1;
                            if (!summary.failuresBySeed[seed]) summary.failuresBySeed[seed] = [];
                            summary.failuresBySeed[seed].push(depth);

                            // Track terrain type transitions
                            for (const d of diffs) {
                                const key = `${d.aName}→${d.bName}`;
                                summary.terrainDiffTypes[key] = (summary.terrainDiffTypes[key] || 0) + 1;
                            }

                            assert.equal(diffs.length, 0,
                                `seed=${seed} depth=${depth}: ${formatDiffs(diffs)}`);
                        }
                    });
                }
            });
        }

        // Print summary after all tests
        describe('SUMMARY', () => {
            it('prints comparison summary', (t) => {
                t.diagnostic(`\n=== C-vs-JS Golden Comparison Summary ===`);
                t.diagnostic(`Total: ${summary.total} seed×depth pairs`);
                t.diagnostic(`Pass:  ${summary.pass} (${(100 * summary.pass / Math.max(summary.total, 1)).toFixed(1)}%)`);
                t.diagnostic(`Fail:  ${summary.fail} (${(100 * summary.fail / Math.max(summary.total, 1)).toFixed(1)}%)`);

                if (summary.fail > 0) {
                    // Failures by depth
                    t.diagnostic(`\nFailures by depth:`);
                    const depths = Object.keys(summary.failuresByDepth).map(Number).sort((a, b) => a - b);
                    for (const d of depths) {
                        t.diagnostic(`  depth ${d}: ${summary.failuresByDepth[d]} failures`);
                    }

                    // Depth-1 specific analysis
                    const depth1Fails = Object.entries(summary.failuresBySeed)
                        .filter(([, depths]) => depths.includes(1))
                        .map(([seed]) => Number(seed));
                    const depth1Total = goldenFiles.length;
                    const depth1Pass = depth1Total - depth1Fails.length;
                    t.diagnostic(`\nDepth 1: ${depth1Pass}/${depth1Total} pass`);
                    if (depth1Fails.length > 0) {
                        t.diagnostic(`  Failing seeds: ${depth1Fails.join(', ')}`);
                    }

                    // Top terrain diff types
                    const diffEntries = Object.entries(summary.terrainDiffTypes)
                        .sort((a, b) => b[1] - a[1]);
                    if (diffEntries.length > 0) {
                        t.diagnostic(`\nTop terrain type mismatches (JS→C):`);
                        for (const [key, count] of diffEntries.slice(0, 15)) {
                            t.diagnostic(`  ${key}: ${count}`);
                        }
                    }
                }
            });
        });
    });
}
